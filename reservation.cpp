/* 
 * File:   FlightReservation.cpp
 * Author: Gamze GÃ¼lbahar
 *
 * Created on December 29, 2018
 */

#include <iostream>
#include <cstdlib>
#include <pthread.h>
#include <unistd.h>
#include <vector>
#include <fstream>

using namespace std;

//This is a class for storing information about the seats on the plane.
class Seat {
public:    
    int seatNumber; //Identifier of the seat from 0 to plane capacity
    int client; //Stores the id of the client that reserves the seat
    bool reserved; //Flag that shows whether the seat is reserved
};

//This is a class for storing information about the clients that arrive.
class Client {
public:
    int clientID; //Identifier of the client from 0 to plane capacity.
    int request; //When the client thread generates a random seat request, it is stored in this variable
    bool done; //A flag that shows whether the client succesfully reserved a seat
    pthread_t thread; //ID of the client's thread is stored here
};

vector<Client> clients; //A vector declared to store client objects
vector<Seat> seats; //A vector declared to store seat objects

fstream output; //File stream variable to deal with file operations

int planeCapacity; //A global variable to store the plane capacity

pthread_mutex_t serverMutex; //Mutual exclusion variable of POSIX threads, to define a critical section in server thread routine

void *clientRoutine(void *at) {
    
    long index = (long) at; //Argument sent by the main thread is the index of the client in the clients vector
    
    int waitingTime = (rand()%151+50)*1000; //A random waiting time is generated for each client thread
    usleep(waitingTime); //Since this function sleeps in microseconds, random number is multiplied by 1000 
   
    int request = rand() % planeCapacity; //A random request between 0 and plane capacity is generated by the client thread
    //If that seat is already reserved, try until finding one that is not
    while(seats.at(request).reserved) request = rand() % planeCapacity; 
    clients.at(index).request = request; //Request is stored to the client object so that the server can see it
    
    usleep(1000*10); //Clients wait for the server to reserve the seat
    
    /*
     * This section of the client thread routine could have been a critical section, however it was not needed.
     * As it can be seen the server thread routine, the reservation is done in the critical section. 
     * Therefore, even if the client gets preempted by another client, server of this client won't let another
     * server to come and reserve the same seat.
     */
    
    /*
     *This flag (done) is set true by server if the reservation is done.
     *So until it is true, the request is repeated with 2 miliseconds waiting time
     */
    while(!clients.at(index).done){ 
        request = rand() % planeCapacity; //A new request is generated,
        while(seats.at(request).reserved) request = rand() % planeCapacity; //Finds a seat that is not reserved
        clients.at(index).request = request; //Request is stored in the object
        usleep(2000); //Waits for the server
    }
    
    pthread_exit(NULL); //When the client is done, the thread can exit
}

void *serverRoutine(void *at) {
   
    long clientNumber; //This variable stores the index of the client in the vector, rather than the actual client ID
    clientNumber = (long)at; //Index is sent as an argument by the main thread
            
    int request = clients.at(clientNumber).request; // Request of the client is taken from its object
    
    while(request == -1) request = clients.at(clientNumber).request; //If the request is not made yet, waits for it in a loop
    
    //In this loop, the seat is checked, reserved if available, and the client is done
    while(!clients.at(clientNumber).done){ //So, as long as client is not done
        //Starts a critical section because glabal variables will be changed
        pthread_mutex_lock(&serverMutex); //Mutex of POSIX is used for initiating the critical section
        if(!seats.at(request).reserved){ //If the requested seat is not reserved, reserves it for the client
            
            seats.at(request).client = clients.at(clientNumber).clientID; //Client ID is written to the seat object
            seats.at(request).reserved = true; //Seat object is marked as reserved
            clients.at(clientNumber).done = true; //Client object is marked done
            
            output.open("output.txt", ios::out | ios::app ); //Output file is opened
            output  << "Client" << clientNumber+1 
                    << " reserves seat" << seats.at(request).seatNumber << endl; //Reservation is logged
            output.close(); //Output file is closed
            
        }
        pthread_mutex_unlock(&serverMutex); //Mutex is unlocked, end of critical section
        
        request = clients.at(clientNumber).request; //If the loop is to continue, take the request again
    }
    
    pthread_exit(NULL); //Server thread is done, it can exit
}
/*
 * 
 */ 
int main(int argc, char** argv) {
    
    planeCapacity = atoi(argv[1]); //Global variable planeCapacity is determined by argument 1 of the main program
    
    while(planeCapacity < 50 || planeCapacity > 100){ //If the argument is given out of accepted range
        cout << "Acceptable range for plane capacity is 50-100. Please make your input accordingly: ";
        cin >> planeCapacity; //User is required to give another input for plane capacity
    }
    
    output.open("output.txt", ios::out | ios::app ); //Output file is opened
    output  << "Number of total seats: " << planeCapacity << endl; //Number of seats is written to the file
    output.close(); //Output file is closed
    
    Seat seat; //A seat object is created
    seat.reserved = false;
    for(int i=1; i <= planeCapacity; i++){ //As many seat objects as plane capacity
        seat.seatNumber = i; //Seat number is incremented sequentially
        seats.push_back(seat); //Seat object is pushed to the vector
    }
    
    Client client; //A client object is created
    client.request = -1;
    client.done = false;
    for(int id=1; id <= planeCapacity; id++){ //As many client objects as plane capacity
        client.clientID = id;  //Client id is updated at each iteration
        clients.push_back(client); //The object is pushed to the vector
    }
    
    pthread_t servers[planeCapacity]; //An array to store server thread ids
         
    int errorStatus; //A variable to store whether the thread creation is successful
    
    pthread_mutex_init(&serverMutex, NULL); //Mutual execution for server threads is initiated 

    for(long i = 0; i < planeCapacity; i++ ) { //This loop creates as many client and server threads as plane capacity
       
        //Client thread is created, its id stored in the clients vector. It starts clientRoutine and sends i as index parameter.
        errorStatus = pthread_create(&clients.at(i).thread, NULL, clientRoutine, (long *)i);
       
        if (errorStatus) { //Successful creation returns 0. Otherwise log an error message to console.
           cout << "Error:unable to create client" << (i+1) << ". Error status: " << errorStatus << endl;
           exit(-1);
        }
        
        //Server thread is created, its id stored in the servers array. It starts serverRoutine and sends i as index parameter.
        errorStatus = pthread_create(&servers[i], NULL, serverRoutine, (long *)i);

        if (errorStatus) {
           cout << "Error:unable to create server" << (i+1) << ". Error status: " << errorStatus << endl;
           exit(-1);
        }
       
    }
    
    /*
     * Main thread should join all the threads so that it waits for all of them to finish.
     * Otherwise, the main thread will keep executing after creating other threads.
     * This will cause the main thread to destroy mutex variable.
     * If the main destroys mutex variable, synchronization will fail.
     */
    for( int i = 0; i < planeCapacity; i++ ) {
       pthread_join(servers[i], 0); 
    }
    
    pthread_mutex_destroy(&serverMutex); //When all the threads are done, mutex variable is destroyed
    
    int count=0;
    for(int i = 0; i < planeCapacity; i++){ 
        if(seats.at(i).reserved) count++; //Counts the successfully reserved seats
    }
    
    output.open("output.txt", ios::out | ios::app );
    if(count == planeCapacity){ //If the count equals to capacity,
        output  << "All seats are reserved." << endl; // it means all seats are reserved successfully
    }else{ //If not, then it means there was a problem.
        output  << "Due to some reason, reserving all the seats has failed." << endl;
    }
    output.close();
    
    cout << "Your file is ready. Bye!" << endl;
    
    pthread_exit(NULL); //Finally, main thread exits

    return 0;
}
